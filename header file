#include<stdio.h>
#include<conio.h>
#include<algorithm>
#include<numeric>
#include<iostream>
#include<functional>
#include<fstream>

#include "opencv2/opencv.hpp"
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/types_c.h>
#include <opencv2/video/video.hpp>
#include <opencv2/video/background_segm.hpp>

#include<Windows.h>
#include <math.h>


using namespace std;
using namespace cv;


int capture_camera()
{
	//Capturing frame as image
	VideoCapture cap(0);
	if (cap.isOpened() == false)  
	{
	  cout << "Cannot open the video camera" << endl;
	  cin.get(); 
	  return -1;
	} 


	 string window_name = " CameraFeed";
	 namedWindow(window_name); 
 
	 while (true)
	 {
	  Mat frame;
	  bool bSuccess = cap.read(frame); 
  
	  imshow(window_name, frame);

  
	  if (waitKey(10) == 27)
	  {
	   cout << "Esc key is pressed by user. Stoppig the video" << endl;

	   imwrite("f.png", frame);
	   break;
  
	  }
	}
}

cv::Mat getImage(char* path)
{
	Mat src = imread(path); 
	return src;
}

//void getImage(char* path, cv::Mat& src)
//{
//	src = imread(path); 
//	//imshow("CameraFeed", src);
//}

cv::Mat edgeDetected(cv::Mat& src)
{
	cv::Mat tempSrc = src.clone();

	Mat gray, edge, draw,blurrr;
	cvtColor(tempSrc, gray, CV_BGR2GRAY);
 
	Canny( gray, edge, 50, 150, 3);
 
	edge.convertTo(draw, CV_8U);
	GaussianBlur(draw, blurrr, Size(9, 9), 2, 2 );
	//imshow("Grayscale", gray);
	//imshow("edge1", edge);
	//imshow("draw1", draw);
	//imshow("blured", blurrr);
	return blurrr;

}


cv::Mat edgeDetected1(cv::Mat& cropImage)
{
	cv::Mat temp = cropImage.clone();
	 Mat dst, cdst;
	Canny(temp, dst, 50, 200, 3);
	//cvtColor(dst, cdst, CV_GRAY2BGR);
		
	return dst;

}
cv::Mat edgeDetected2(cv::Mat& cropImage)
{
	cv::Mat temp = cropImage.clone();
	 Mat dst, cdst;
	Canny(temp, dst, 50, 200, 3);
	cvtColor(dst, cdst, CV_GRAY2BGR);
		
	return cdst;

}




cv::Mat HGCircle(cv::Mat& blurrr, cv::Mat& src)
{

	cv::Mat tempSrc = src.clone();
	vector<Vec3f> circles;
	HoughCircles( blurrr, circles, CV_HOUGH_GRADIENT, 1, blurrr.rows/8, 210, 210, 0, 0 );
	cv::Mat mask = Mat::zeros(src.rows, src.cols, CV_8UC1);

	for( size_t i = 0; i < circles.size(); i++ )
	{
		Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
		int radius = cvRound(circles[i][2]);
		// circle center
		circle( tempSrc, center, 3, Scalar(0,255,0), -1, 8, 0 );
		// circle outline
		circle( tempSrc, center, radius, Scalar(0,0,255), 1, 8, 0 );

		circle( mask, center, radius, 255, -1, 8, 0 );
	}
	//imshow( "Hough Circle Transform ", tempSrc );

	return mask;
}


 cv::Mat Sector(cv::Mat& src)
{


  cv::Mat temp = src.clone();
  Point ce;//center of detected circle
  ce.x=330;
  ce.y=238;
  int angle=-6;
  int length=150;
  Point endx;
  for(int j=0;j<=59;j++)
  {

  endx.x= (ce.x + length*cos(angle*CV_PI/180.0));
  endx.y= (ce.y + length*sin(angle*CV_PI/180.0));
  line( temp, ce, endx, Scalar(0,0,255), 1, 8, 0);
  angle=angle+6;
  }
  //namedWindow( "Sector1 ", CV_WINDOW_AUTOSIZE );
  //imshow( "Sector1 ", src );
  return temp;

  

}

cv::Mat HGline(cv::Mat& dst1, cv::Mat& cropImage1)
{
	vector<Vec4i> lines;
	HoughLinesP(dst1, lines, 1, CV_PI/180, 50, 50, 10 );
	for( size_t i = 0; i < lines.size(); i++ )
		{
			Vec4i l = lines[i];
			line( cropImage1, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(0,255,0), 1, CV_AA);
		}   

	return cropImage1;


}





